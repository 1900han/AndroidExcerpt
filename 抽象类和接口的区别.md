## 抽象类

**抽象类是用来捕捉子类的通用特性的。它不能被实例化，只能被用作子类的超类，抽象类是被用来创建继承层级里子类的模版。**

**抽象类体现了数据抽象的思想，是实现多态的一种机制。它定义了一组抽象的方法，至于这组抽象方法的具体表现形式由派生类来实现，同时抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。所以说定义的抽象类一定是用来继承的，同时在一个以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类。**

1. 抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。
2. 抽象方法必须由子类进行**重写**。
3. 只要包含**一个**抽象方法的抽象类，该方法**必须**要定义成抽象类，不管是否还包含有其他方法。
4. 抽象类中**可以包含**具体的方法，当然也**可以不包含**抽象方法。
5. 子类中的抽象方法**不能**与父类中的抽象方法**同名**。
6. abstract**不能**与final并列修饰一个类。
7. abstract不能与private、static、final、native并列修饰同一个方法。

## 接口

**接口是抽象方法的集合。如果一个类实现了某个接口，那个它就继承了这个接口的抽象方法。这就像契约模式，如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情。**

**接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用*implements*关键字。接口是抽象类的延伸，java为了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，使用接口弥补了抽象类不能多重继承的缺陷。**

1. 由interface关键词修饰的称之为接口。
2. 接口中定义成员变量，但是这些变量默认是public static final。
3. 接口中没有已经实现的方法，全部是**抽象方法**。
4. 一个类实现某一接口，必须实现接口中定义的所有方法。
5. 一个类可以实现多个接口。

## 区别

语法层次，如上所述

设计层次

1. 抽象层次不同。抽象类是**对类抽象**，而接口是对**行为的抽象**。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。
2. 跨域不同。**抽象类所跨域的事具有具有相似特点的类，而接口却可以跨域不同的类**。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同，实现它的子类可以不存在任何关系，共同之处。例如猫，狗可以抽象成一个动物类抽象类，具备叫的方法。鸟，飞机可以实现飞接口，具备飞的行为，这里总不能将鸟、飞机共用一个父类吧。所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在**“is-a”**关系，即父类和派生类在***概念本质*上*应该是相同***的，对于接口则不然，并不要求接口的实现者和和接口定义在概念本质上是一致的，仅仅是实现了接口定义的契约而已，相当于是**“like-a”**的关系
3. 设计层次不同。对于抽象类而言，它是**自底向上来抽象**的，要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如只有一个猫类在这里，如果你这就抽象成一个动物类，是不是设计有点过度？我们起码要有两个动物类，猫，狗在这里，我们在抽象他们的共同点形成动物抽象类。所以说抽象类往往都是重构而来的！但是接口不同，比如飞，根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。**所以说抽象类是自底向上抽象而来的，接口则是自顶向下设计出来的。**

**空接口的作用**

通常作为一个标记，比如Serializable、Clonable

## 参考

[java提高篇（四）-----抽象类与接口](http://blog.csdn.net/chenssy/article/details/12858267)

[Java抽象类与接口的区别](http://www.importnew.com/12399.html)

